[{"categories":["Operating System"],"contents":"Process State 프로세스는 아래와 같은 5가지의 상태(State)를 가진다.\n   상태 설명     new 프로세스가 만들어지기 전인 상태 (아직 프로세스가 아님)   ready 프로세스가 메모리에서 CPU에 할당되기를 기다리는(ready) 상태   running CPU가 프로세스의 명령을 수행하고 있는 상태   waiting 프로세스가 특정 event (e.g. I/O operation,..) 가 일어나기를 기다리고 있는 상태   terminated 프로세스의 작업이 끝난 상태 (더 이상 프로세스가 아님)    주의  CPU core 하나 당 오직 하나의 프로세스만 running 상태 다른 프로세스는 ready 또는 waiting 상태  Process Scheduling CPU scheduler가 ready queue에서 프로세스 하나를 선택(CPU Scheduling)해 processor에 올려준다(dispatch).\n그리고 running 상태인 프로세스가 특정 event를 기다리기 위해 waiting queue에 들어간다.\n이러한 과정을 Process Scheduling이라고 한다.\n Ready Queue: ready 상태인 프로세스들을 말한다. Waiting Queue: 특정 event를 기다리는 중인 waiting 상태의 프로세스 리스트를 말한다.  각 Queue는 다음과 같은 특징을 가진다.\n PCB로 이루어진 linked list head와 tail을 가리키는 Queue header  Process Context 프로세스의 Context는 CPU execution context, Process memory space, Process management in OS에 의해 결정된다.\n CPU execution context:  Program Counter(PC) Registers   Process memory space  code, data, stack   Process management in OS  Process Control Block(PCB) Kernel stack    Context Switch OS가 현재 실행중인 프로세스를 다른 프로세스로 바꾸는 것을 말한다.  참고 자료  학교 강의자료 Operating System Concepts 9th edition  부족한 점이 있다면 댓글로 알려주세요!\n","permalink":"https://kjw217.github.io/posts/cs/os/operating-system-03-process-scheduling/","tags":["Process","Scheduling"],"title":"[Operating System] 03 Process Scheduling"},{"categories":["Operating System"],"contents":"Process A program in execution\n실행중인 프로그램\nProcess in Memory 다음 그림은 메모리 영역을 나타낸 그림이다.\n각 영역은 text, data, stack, heap이라는 이름으로 정의되었으며, data영역은 대략 아래와 같이 3가지로 나뉜다고 한다.\nText 영역 프로그램의 실행 코드가 존재하며, 컴파일된 binary assembly code 또한 이 곳에 저장된다\n 프로그램 실행코드 컴파일된 Binary Assembly Code  Data 영역 전역변수와 static symbol이 저장되는 영역이다.\n해당 영역을 쓰임새에 따라 다음 3가지 영역으로 나뉜다.\n 읽기 전용으로 초기화되는 영역: .rodata  const로 선언 되는 영역 각종 문자열 (e.g. printf()문의 format string, 상수 문자열..)   읽기/쓰기가 가능한 영역으로 초기화 되는 영역: .data  초기값을 갖는 전역변수   초기화되지 않은 영역: BSS(Block Started by Symbol)  초기화되지 않은 전역변수 static으로 선언된 symbol       변수 영역     int i; BSS 영역   int i = 1; .data 영역   char str[] = \u0026ldquo;Hi\u0026rdquo;; .data 영역, 읽기/쓰기 가능   char * pstr = \u0026ldquo;Hi\u0026rdquo;; 문자열은 .rodata 영역, pstr 변수는 .data 영역   const char str[] = \u0026ldquo;Hi\u0026rdquo;; 문자열은 .rodata 영역, str 변수는 .data 영역   static int i; BSS 영역    Stack 영역 function call을 통해 stack 영역 내에 매개변수, 반환 주소값, 지역변수에 대한 영역을 할당한다.\nfunction call이 일어날 때마다 앞서 말한 3가지가 스택처럼 할당된다. PUSH\nfunction 호출이 완료되었을 땐, 스택에서 사라진다. POP 위와 같이 스택 영역에 차례대로 저장되는 함수의 호출 정보를 스택 프레임(Stack Frame)이라고한다.\n스택 프레임(Stack Frame) 동작과정 아래와 같은 코드가 있을 때 스택 프레임의 동작과정을 살펴보자\n아래 과정은 TCP school 스택 프레임과 같은 예시이다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  int main(void) { func1(); // func1() 호출  return 0; } void func1() { func2(); // func2() 호출 } void func2() { }    STEP 01\u0026gt; 프로그램이 실행되면, 가장 먼저 main() 함수가 호출되어 main() 함수의 스택 프레임이 스택에 저장(PUSH) STEP 02\u0026gt; func1() 함수를 호출하면 해당 함수의 매개변수, 반환 주소값, 지역 변수 등의 스택 프레임이 스택에 저장 STEP 03\u0026gt; func2() 함수를 호출하면 해당 함수의 스택 프레임이 추가로 스택에 저장 STEP 04\u0026gt; func2() 함수의 모든 작업이 완료되어 반환되면, func2() 함수의 스택 프레임만이 스택에서 제거(POP) STEP 05\u0026gt; func1() 함수의 호출이 종료되면, func1() 함수의 스택 프레임이 스택에서 제거 STEP 06\u0026gt; main() 함수의 모든 작업이 완료되면, main() 함수의 스택 프레임이 스택에서 제거되면서 프로그램이 종료  Heap 영역 사용자가 직접 관리할 수 있는 영역 malloc()이나 new 연산자를 통해 메모리를 동적할당할 수 있다.\n사용자는 메모리의 할당(new)과 해제(free)를 직접 관리해야하며, 객체지향언어(C++/Java)에서는 Garbage Collection이 제공되지만 그래도 직접적인 관여는 필요하다.\nProcess Management 각 프로세스는 OS에 등록되고 OS가 관리한다.\n이를 위해 OS는 각 프로세스의 정보를 담은 Data Structure가 필요하다.\n이를 PCB(Process Control Block)이라고 한다.\nPCB(Process Control Block) Process state, Process number(pid), Program Counter(PC), CPU registers 등을 포함한다.\n 참고 자료  학교 강의자료 Operating System Concepts 9th edition ffun님 Tistory의 메모리 구조 정리글 TCP school 메모리 구조 TCP school 스택 프레임  부족한 점이 있다면 댓글로 알려주세요!\n","permalink":"https://kjw217.github.io/posts/cs/os/operating-system-02-process-concept/","tags":["Process"],"title":"[Operating System] 02 Process Concept"},{"categories":["Operating System"],"contents":"Challenging Issues  At any given time, each resource can serve only one process   OS -\u0026gt; Process Management   Multiple processes can be executed while sharing memory   OS -\u0026gt; Memory Management   Using I/O device takes a long time, and CPU is idle and underutilized   OS -\u0026gt; I/O Management   An unauthorized process causes a system fault although other processes have no problem   OS -\u0026gt; Protection   Process Management  process: 실행중인 프로그램 process(thread) scheduling   Memory Manageement  CPU reads both instructions and data from main memory multitasking (Virtual) Memory Manangement   I/O Subsystem  There is always a device driver and device controller for each I/O device I/O request from application device controller takes action device controller informs the CPU via an interrupt that it has finished    Basic Operations OS의 기본적인 동작에는 multitasking, interrupt, protection이 있다\nMultitasking 메인메모리에 동시에 올라와 있는 process들은 CPU time이나 I/O devices와 같은 resource를 공유한다.\n이를 관리하고 조정하는 게 멀티태스킹.\n 장점  CPU Utilization  Keep several jobs in memory simultaneously One job selected and run via scheduling   Time Sharing  CPU switches jobs so frequently: illusion of multitasking which process do we run first?: CPU Job Scheduling      Interrupt Interrupt: device의 작업이 끝났음을 CPU에게 알리는 수단\n Hardware Interrupt: Hardware I/O device interrupt CPU Software Interrupt: Software programs interrupt CPU  System calls: application program이 kernel functions을 call하기 위해 사용 Exceptions: divide by zero exception   Interrupt Handler  CPU가 interrupt되면, 하던거 멈춤 interrupt vector(interrupt한 device의 드라이버 위치)로 interrupt service routine을 실행 service routine을 끝내면 다시 하던거 함     Protection OS와 user는 컴퓨터 시스템의 HW/SW를 공유한다.\nMalicious program이 다른 프로그램에 해를 끼치지 못하도록 하기위해 OS code와 user code를 구별해야했다.\nDual-mode operation Kernel mode와 User mode를 구분\n하드웨어(e.g. CPU)에서 Mode bit를 가짐(Kernel:0, user:1)\n 참고 자료  학교 강의자료 Operating System Concepts 9th edition  부족한 점이 있다면 댓글로 알려주세요!\n","permalink":"https://kjw217.github.io/posts/cs/os/operating-system-01-structure/","tags":["Structure"],"title":"[Operating System] 01 Structure"},{"categories":["Operating System","Intro"],"contents":"Operating System A collection of computer programs.\n mananges computer hardware resources. provides a basis for application programs. acts as an interface between the computer user and the computer hardware.  What OSes do  User View:  Command Line Interface(CLI) Graphical User Interface(GUI) Touch Screen Interface   System View: Kernel  A collection of programs that is an interface OS makes hardware useful to the programmer OS controls user programs 간단한 가정을 가진다  한번에 하나의 프로그램만 실행된다 나쁜 유저는 없다   하드웨어나 유저의 사용성에서 문제가 생길 수 있다 OS provides mechanisms to address the problems  preemption: looping process로 부터 CPU resource를 다시 가져옴 Memory Protection: 다른 process의 메모리 영역을 침범하지 못하게 함      Computer System 하드웨어, OS, application programs, 유저로 나뉜다\n 참고 자료  학교 강의자료 Operating System Concepts 9th edition  부족한 점이 있다면 댓글로 알려주세요!\n","permalink":"https://kjw217.github.io/posts/cs/os/operating-system-00-intro/","tags":["Introduction","Overview"],"title":"[Operating System] 00 Intro"},{"categories":["Hugo","Github Pages","Blog"],"contents":"내가 가진 테마인 northendlab-hugo 테마에서 nested sections를 이용해 트리 구조의 카테고리 탭을 만들었던 과정을 기록하겠다.\n기존 northendlab 테마 헤더의 탭  단순한 탭으로 된 형태의 메뉴 목표: 이걸 지금처럼 드롭다운 형태의 카테고리 형식의 메뉴로 만들기  목표를 위해 필요한 것  테마의 partials 디렉토리에서 header.html의 메뉴부분 구조 확인 config.toml에서 identifier와 parent 설정 메뉴를 만들기 위해 필요한 디렉토리를 config.toml에 설정한 url에 맞게 생성  이 때, 디렉토리 명은 항상 소문자로 해야한다. 필자는 대문자로 했다가 밤새고, 다음날 자기혐오에서 헤어나올 수 없었다.    header.html의 메뉴 구조 확인하기 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  \u0026lt;!--northendlab-hugo/layouts/partials/header.html 메뉴 부분 --\u0026gt; \u0026lt;ul class=\u0026#34;navbar-nav ml-auto\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;!--home tab --\u0026gt;  \u0026lt;a class=\u0026#34;nav-link\u0026#34; href=\u0026#34;{{ .Site.BaseURL }}\u0026#34;\u0026gt; {{ with .Site.Params.Home }} {{ . }} {{ end }} \u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; {{ range .Site.Menus.main }} \u0026lt;!--menu --\u0026gt; {{ if .HasChildren }} \u0026lt;!--자식 노드를 가진다면 --\u0026gt;  \u0026lt;li class=\u0026#34;nav-item dropdown\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link dropdown-toggle\u0026#34; href=\u0026#34;#\u0026#34; role=\u0026#34;button\u0026#34; data-toggle=\u0026#34;dropdown\u0026#34; aria-haspopup=\u0026#34;true\u0026#34; aria-expanded=\u0026#34;false\u0026#34;\u0026gt; {{ .Name }} \u0026lt;/a\u0026gt; \u0026lt;div class=\u0026#34;dropdown-menu\u0026#34;\u0026gt; {{ range .Children }} \u0026lt;!--자식 노드 출력 --\u0026gt;  \u0026lt;a class=\u0026#34;dropdown-item\u0026#34; href=\u0026#34;{{ .URL | absURL }}\u0026#34;\u0026gt; {{ .Name }} \u0026lt;/a\u0026gt; {{ end }} \u0026lt;/div\u0026gt; \u0026lt;/li\u0026gt; {{ else }} \u0026lt;!--자식 노드를 가지지 않는다면 --\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt;  \u0026lt;a class=\u0026#34;nav-link\u0026#34; href=\u0026#34;{{ .URL | absURL }}\u0026#34;\u0026gt;{{ .Name }}\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; {{ end }} {{ end }} \u0026lt;/ul\u0026gt;    line 4: home tab을 출력 line 9 ~: main이라는 Menu에 들어 있는 목록을 출력  만약 자식 노드가 있다면 자식까지 출력 없다면 단일 출력   이 코드에서 궁금했던 것 (모두 config.toml 파일에서 설정함)  main이라는 이름의 메뉴를 어떻게 Menu라는 변수에 추가하는 지 추가된 메뉴에는 parent와 children의 관계를 어떻게 추가하는 지 Name이라는 변수는 어떻게 정해지는 지    config.toml 설정하기  앞선 단계에서 궁금했던 것들을 config.html 파일을 통해 해결할 수 있었다.\n main이라는 이름의 메뉴를 어떻게 Menu라는 변수에 추가하는 지  [[menu.\u0026lt;메뉴이름\u0026gt;]] 추가   추가된 메뉴에는 parent와 children의 관계를 어떻게 추가하는 지  parent의 identifier와 children의 parent 설정   Name이라는 변수는 어떻게 정해지는 지  메뉴를 만들면서 name 설정     1 2 3 4 5 6 7 8 9 10 11 12 13  #config.toml [[menu.main]] # [[menu.\u0026lt;메뉴이름\u0026gt;]] URL = \u0026#34;posts\u0026#34; # URL: \u0026lt;content 디렉토리 아래의 디렉토리 위치\u0026gt; name = \u0026#34;Posts\u0026#34; # name: \u0026lt;디렉토리의 원하는 이름\u0026gt; identifier = \u0026#34;Posts\u0026#34; # identifier: \u0026lt;children이 parent를 지정할 때 필요 weight = 1 # weight: 메뉴 순서 [[menu.main]] URL = \u0026#34;posts/languages/\u0026#34; name = \u0026#34;Languages\u0026#34; identifier = \u0026#34;Languages\u0026#34; parent = \u0026#34;Posts\u0026#34; # parent: parent의 identifier     참고 자료  northendlab-hugo demo northendlab github Hugo docs - menu  부족한 점이 있다면 댓글로 알려주세요!\n","permalink":"https://kjw217.github.io/posts/makeblog/hugo/hugogithub-pages-theme-customizing-01-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC-%EB%A7%8C%EB%93%A4%EA%B8%B0/","tags":["Category Tab","Customizing"],"title":"[Hugo\u0026Github Pages] Theme Customizing 01 카테고리 만들기"},{"categories":["Hugo","Blog"],"contents":"Utterances  Utterances configuration 페이지를 해석해보면 Github 이슈 검색 API를 활용해 url, pathname, title을 기반으로 페이지(e.g. 포스트)과 관련된 이슈를 찾는다고 한다. by영알못 만약, Issue가 달리지 않은 글이라도 누군가 댓글을 달게 되면 utterances bot이 알아서 Issue를 생성해주기 때문에 걱정말란다. 무엇보다 블로그에 붙이기가 매우 편하다.\n Utterances 사용법  utterances docs로 들어가서 아래와 같은 순서로 진행한다.\nConfiguration 부분을 설명해둔 것이니 영어에 자신있다면 해당 포스트는 안 보고 해도 무방하다.\n Repository  Utterances와 연결할 Github 저장소를 하나 생성한다. 저장소는 반드시 public으로 생성한다.\n(필자는 이미 kjw217/blog-comments를 생성했기에 생성할 수 없다고 뜨는 것)  새로 만든 저장소에 Utterances app을 설치한다.  configure 버튼을 클릭  새로 만든 저장소가 있는 계정(?그룹?) 선택 필자는 이미 댓글 기능을 만든 상태이기에 configure 되어있음  Select repositories를 클릭하고 새로 만든 저장소를 선택 후 SAVE 버튼 클릭    여기까지 왔다면, 새로 만든 저장소의 Settings 탭에서 Issues 항목을 체크한다.  utterances docs의 Configuration에 있는 빈칸에 새로만든 저장소 이름을 owner/repo형식으로 입력한다.   Blog Post ↔️ Issue Mapping  Blog Post와 Issue를 mapping하기 위한 방법을 선택한다\n  Issue title이 page의 pathname을 포함하는 Issue와 page(post)를 mapping Issue title이 page의 url을 포함하는 Issue와 page(post)를 mapping Issue title이 page의 title을 포함하는 Issue와 page(post)를 mapping Issue title이 page의 og:title을 포함하는 Issue와 page(post)를 mapping  여기서 og:title은 meta 데이터를 말하는 듯   Page(post)마다 specific number를 배정 Issue title이 특정 단어를 포함하는 Issue와 page(post)를 mapping  Issue Label  utterances bot이 생성할 이슈에 붙을 Label의 이름을 짓는 것이다.\n Theme  테마는 원하는 거 고르자\n Enable Utternaces  지금까지 구성했던 사항들로 작성된 코드이다.\n그대로 COPY해서 댓글을 넣고 싶은 .html파일의 원하는 부분에 붙여넣기 하면 된다.\n  참고 자료  Hugo로 github.io 블로그 만들기 Outsider's Dev Story utterances astrod님의 utterances 적용  부족한 점이 있다면 댓글로 알려주세요!\n","permalink":"https://kjw217.github.io/posts/makeblog/hugo/hugogithub-pages-tutorial03-%EB%8C%93%EA%B8%80%EA%B8%B0%EB%8A%A5-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0/","tags":["utterances","comment open source","Github api"],"title":"[Hugo\u0026Github Pages] Tutorial03 댓글기능 추가하기"},{"categories":["Blog","Hugo","Github Pages"],"contents":"Github repository 생성하기  Github의 repository는 총 2개가 필요하다.\n C:\\Hugo\\blog의 전체 내용을 담을 repository 이후에 생성될 C:\\Hugo\\public의 생성된 정적 웹페이지를 담을 repository    첫 번째 저장소는 원하는 이름blog으로 생성 두 번째 저장소는 \u0026lt;github계정\u0026gt;.github.io라는 이름으로 생성   첫 번째 저장소를 C:\\Hugo\\blog의 remote로 설정 1 2 3  $ cd blog $ git init $ git remote add origin \u0026lt;first-github-repository-url\u0026gt;    두 번째 저장소를 C:\\Hugo\\blog의 submodule로 설정 1 2  $ cd blog $ git submodule add -b master \u0026lt;second-github-repository-url\u0026gt; public    위 명령을 통해 C:\\Hugo\\blog\\public 디렉토리 생성됨    Contents 업로드하기  C:\\Hugo\\blog로 이동 $ hugo -t \u0026lt;theme-name\u0026gt; 명령을 통해 테마가 적용된 블로그를 public에 생성 C:\\Hugo\\blog\\public로 이동 \u0026lt;username\u0026gt;.github.io repository에 수정된 블로그 push  git add . 수정된 파일들을 index에 올림 git commit -m \u0026quot;\u0026lt;commit-message\u0026gt;\u0026quot; 변경 내용을 commit git push origin master commit된 내용을 remote에 push   blog 저장소에도 변경내용 push  C:\\Hugo\\blog로 이동 git add . git commit -m \u0026quot;\u0026lt;commit-message\u0026gt;\u0026quot; git push origin master    업로드 자동화 파일 deploy.sh  아래 스크립트 복사해서 deploy.sh파일을 C:\\Hugo\\blog에 둔다. 반드시 테마명은 자신이 선택한 테마로 변경한다. 스크립트 실행 방법은 C:\\Hugo\\blog에서 $ bash deploy.sh입력  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  #!/bin/bash  echo -e \u0026#34;\\033[0;32mDeploying updates to GitHub...\\033[0m\u0026#34; # Build the project. 여기 테마명 바꾸세요 hugo -t northendlab-hugo # Go To Public folder cd public # Add changes to git. git add . # Commit changes. msg=\u0026#34;rebuilding site $(date)\u0026#34; if [ -n \u0026#34;$*\u0026#34; ];then msg=\u0026#34;$*\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. git push origin master # Come Back up to the Project Root cd .. # blog repos Commit \u0026amp; Push git add . msg=\u0026#34;rebuilding site $(date)\u0026#34; if [ -n \u0026#34;S*\u0026#34;];then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; git push origin master    참고 자료  Hugo Docs Hugo로 github.io 블로그 만들기  부족한 점이 있다면 댓글로 알려주세요!\n","permalink":"https://kjw217.github.io/posts/makeblog/hugo/hugogithub-pages-tutorial02-github-%EC%A0%80%EC%9E%A5%EC%86%8C-%EC%83%9D%EC%84%B1-%EB%B0%8F-%EC%97%85%EB%A1%9C%EB%93%9C/","tags":["github.io"],"title":"[Hugo\u0026Github Pages] Tutorial02 Github 저장소 생성 및 업로드"},{"categories":["Hugo","Github Pages","Blog"],"contents":"Hugo 설치하기  Hugo installation 페이지로 가면 설치방법을 영어로 설명하고 있다.\n다만, 필자는 Windows를 사용하기에 이 영상을 보고 설치했다.\n영상 내용을 요약하면 아래와 같다:\n  원하는 위치에 Hugo 및 bin 디렉토리(폴더) C:\\Hugo\\bin생성 Hugo releases에서 OS에 맞는 압축파일 다운로드 다운받은 압축파일을 방금 생성한 폴더 C:\\Hugo\\bin에 압축 해제 환경변수를 설정 두 가지 방법 중 택 1  커맨드 라인에서 C:\\Hugo\\bin으로 이동해 $ set PATH=%PATH%;C:\\Hugo\\bin 명령어 설정 또는, 내 컴퓨터(우클릭)\u0026gt;속성\u0026gt;고급 시스템 설정\u0026gt;고급 탭\u0026gt;환경 변수 버튼\u0026gt;사용자 변수의 Path 클릭\u0026gt;편집 버튼에 hugo.exe 파일이 있는 경로 C:\\Hugo\\bin 추가   명령 프롬프트(cmd)나 git bash에서 $ hugo version 명령어로 hugo가 설치되었는지 확인 혹시라도 version이 나오지 않는다면 GO 설치여부를 확인하거나 재부팅  Hugo 블로그 디렉토리 구조 생성하기  이 단계에서는 커맨드 라인 명령어를 사용해야 한다.\nmac OS나 Linux를 사용한다면 원래 하던대로 커널을 이용하면 된다.\n필자는 Windows를 사용하기에 git bash를 사용했다.\n  다음 명령어를 통해 새로운 사이트 생성 1 2  $ cd \u0026lt;Hugo-directory-path\u0026gt; # C:\\Hugo로 이동 $ hugo new site \u0026lt;blog-name\u0026gt; # 새로운 사이트 생성 (필자는 \u0026#39;blog\u0026#39;)    아래와 같은 디렉토리 구조가 생성되었다면 성공 Hugo |-blog #\u0026lt;blog-name\u0026gt;을 말한다 |-archetypes | |-default.md |-content |-data |-layouts |-static |-themes |-config.toml   블로그 테마 설정하기  https://themes.gohugo.io/ 원하는 테마 선택 C:\\Hugo\\blog 디렉토리로 이동한 후에 아래 명령으로 테마 다운로드 1 2  $ git init $ git submodule add \u0026lt;theme-github-url\u0026gt; themes/\u0026lt;theme-name\u0026gt;   \u0026lt;theme-github-url\u0026gt;과 \u0026lt;theme-name\u0026gt;은 테마의 Github 주소와 테마의 이름\n 필자는 다음과 같이 입력 (northendlab 테마를 사용했음)    \u0026lt;theme-github-url\u0026gt; : https://github.com/themefisher/northendlab-hugo.git \u0026lt;theme-name\u0026gt; : northendlab-hugo    테마 홈페이지에서 안내하는 대로 config.toml파일 등을 수정  이 부분은 테마마다 설정해야 할 것이 다르기 때문에 필히 테마 홈페이지 참조   위 과정을 마쳤다면 themes 디렉토리 아래에 테마 폴더 생성됨\n아래 트리는 themes 디렉토리 밑에 폴더가 생성된 것을 표현한 것, 실제와 다를 수 있음 Hugo |-blog |-archetypes | |-default.md |-content |-data |-layouts |-static |-themes | |-northendlab-hugo | |-.. | : |-config.toml   Content 생성하기  C:\\Hugo\\blog 디렉토리로 이동한 후에 아래 명령 입력\n$ hugo new \u0026lt;category-path\u0026gt;/\u0026lt;post-name\u0026gt;.\u0026lt;post-format\u0026gt;\n 1  $ hugo new posts/my-first-post.md    위 명령어를 통해 content 디렉토리 밑에 posts 디렉토리와 my-first-post.md파일이 생성된다 Hugo |-blog |-archetypes | |-default.md |-content | |-posts | |-my-first-post.md |-data : :  my-first-post.md title: \u0026quot;My First Post\u0026quot; date: 2019-03-26T08:47:11+01:00 draft: true   Hugo server 구동하기 1  $ hugo server -D    위 명령어를 통해 서버 구동 -D 옵션은 post의 property 중 draft: true인 문서도 홈페이지에 띄우겠다는 것 http://localhost:1313/ 을 통해 자신의 블로그에 접근할 수 있다   참고 자료  Hugo Docs Hugo로 github.io 블로그 만들기  부족한 점이 있다면 댓글로 알려주세요!\n","permalink":"https://kjw217.github.io/posts/makeblog/hugo/hugogithub-pages-tutorial01-hugo-%EB%A1%9C%EC%BB%AC-%EC%84%9C%EB%B2%84-%EB%A7%8C%EB%93%A4%EA%B8%B0/","tags":["create blog","installation"],"title":"[Hugo\u0026Github Pages] Tutorial01 Hugo 로컬 서버 만들기"},{"categories":["Hugo","Blog"],"contents":"Hugo  Hugo는 GO언어 기반의 정적 웹사이트 생성기(Static Site Generator 이하 쓱)\nGithub Pages와 함께 사용해 블로그를 만들기 위해 사용\n현재 블로그의 front-end를 생성해주는 역할을 수행 중이다.\nHugo 특징  다른 정적 웹사이트 생성기쓱(e.g. Jekyll, Hexo, and etc..)에 비해 빌드가 빠름 여기에서 Jekyll보다 star가 많음 2019.12.18 기준 내 생각엔 다른 정적 웹사이트 생성기보다 테마 커스터마이징이 쉬웠음  Github Pages  Github에서 무료 공짜 좋아하면 대머ㄹ.. 로 제공해주는 웹호스팅 서비스!\n이를 이용하면 다음과 같은 과정을 통해 개인 웹페이지를 가질 수 있게 된다\n  Github 저장소에 내가 만든 웹페이지를 올림 Github에서 서버를 무료로 제공 개인 웹페이지 생성 및 노출   Github Pages 특징  https://[username].github.io 형식의 개인 웹페이지 주소를 생성 사용이 매우 쉽고 간단하다   참고 자료  Hugo 홈페이지 Github Pages 홈페이지 마이구미의 Hello word, Github Pages란 무엇인가? Tigim Insight, Hugo Static Web Engine  부족한 점이 있다면 댓글로 알려주세요!\n","permalink":"https://kjw217.github.io/posts/makeblog/hugo/hugogithub-pages-tutorial00-%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%86%8C%EA%B0%9C/","tags":["make blog","intro"],"title":"[Hugo\u0026Github Pages] Tutorial00 간단한 소개"},{"categories":null,"contents":"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n","permalink":"https://kjw217.github.io/author/john-doe/","tags":null,"title":"John Doe"},{"categories":null,"contents":"","permalink":"https://kjw217.github.io/author/joowan-kim/","tags":null,"title":"Joowan Kim"},{"categories":null,"contents":"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n","permalink":"https://kjw217.github.io/author/mark-dinn/","tags":null,"title":"Mark Dinn"}]